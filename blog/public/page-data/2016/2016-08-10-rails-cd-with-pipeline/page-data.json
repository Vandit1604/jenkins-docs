{"componentChunkName":"component---src-templates-article-js","path":"/2016/2016-08-10-rails-cd-with-pipeline/","result":{"data":{"asciidoc":{"html":"<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p>ruby</p>\n</li>\n<li>\n<p>pipeline</p>\n</li>\n<li>\n<p>rails</p>\n</li>\n<li>\n<p>brakeman</p>\n</li>\n<li>\n<p>continuousdelivery\nauthor: rtyler\n---</p>\n</li>\n</ul>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>This is a guest post by <a href=\"https://github.com/rtyler\">R. Tyler Croy</a>, who is a\nlong-time contributor to Jenkins and the primary contact for Jenkins project\ninfrastructure. He is also a Jenkins Evangelist at\n<a href=\"https://cloudbees.com\">CloudBees, Inc.</a></p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>When the <a href=\"https://rubyonrails.org\">Ruby on Rails</a> framework debuted it\nchanged the industry in two noteworthy ways: it created a trend of opinionated web\napplication frameworks (<a href=\"https://www.djangoproject.com/\">Django</a>,\n<a href=\"https://playframework.com/\">Play</a>, <a href=\"https://grails.org/\">Grails</a>) and it\nalso <em>strongly</em> encouraged thousands of developers to embrace test-driven\ndevelopment along with many other modern best practices (source control, dependency\nmanagement, etc). Because Ruby, the language underneath Rails, is interpreted\ninstead of compiled there isn&#8217;t a \"build\" per se but rather tens, if not\nhundreds, of tests, linters and scans which are run to ensure the application&#8217;s\nquality. With the rise in popularity of Rails, the popularity of application\nhosting services with easy-to-use deployment tools like <a href=\"https://heroku.com\">Heroku</a> or\n<a href=\"https://engineyard.com\">Engine Yard</a> rose too.</p>\n</div>\n<div class=\"paragraph\">\n<p>This combination of good <strong>test coverage</strong> and easily <strong>automated deployments</strong>\nmakes Rails easy to continuously deliver with Jenkins. In this post we&#8217;ll cover\ntesting non-trivial Rails applications with <a href=\"/doc/pipeline\">Jenkins\nPipeline</a> and, as an added bonus, we will add security scanning via\n<a href=\"https://brakemanscanner.org\">Brakeman</a> and the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/Brakeman+Plugin\">Brakeman\nplugin</a>.</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/ruby-pipeline-2016/cfpapp-stage-view.png\" alt=\"cfpapp stage view\">\n</div>\n</div>\n<div class=\"paragraph\">\n<p><strong>Topics</strong></p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"#_preparing_the_app\">Preparing the app</a></p>\n</li>\n<li>\n<p><a href=\"#_preparing_jenkins\">Preparing Jenkins</a></p>\n</li>\n<li>\n<p><a href=\"#_writing_the_pipeline\">Writing the Pipeline</a></p>\n</li>\n<li>\n<p><a href=\"#_security_scanning\">Security scanning</a></p>\n</li>\n<li>\n<p><a href=\"#_deploying_the_good_stuff\">Deploying the good stuff</a></p>\n</li>\n<li>\n<p><a href=\"#_wrap_up\">Wrap up</a></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>For this demonstration, I used <a href=\"https://rubycentral.org/\">Ruby Central</a>'s\n<a href=\"https://github.com/rubycentral/cfp-app\">cfp-app</a>:</p>\n</div>\n<div class=\"quoteblock\">\n<blockquote>\n<div class=\"paragraph\">\n<p>A Ruby on Rails application that lets you manage your conference&#8217;s call for\nproposal (CFP), program and schedule. It was written by Ruby Central to run the\nCFPs for RailsConf and RubyConf.</p>\n</div>\n</blockquote>\n</div>\n<div class=\"paragraph\">\n<p>I chose this Rails app, not only because it&#8217;s a sizable application with lots\nof tests, but it&#8217;s actually the application we used to collect talk proposals\nfor the \"Community Tracks\" at this\nyear&#8217;s <a href=\"https://jenkinsworld.com\">Jenkins World</a>. For the most part,\ncfp-app is a standard Rails application. It uses\n<a href=\"https://www.postgresql.org/\">PostgreSQL</a> for its database,\n<a href=\"https://rspec.info\">RSpec</a> for its tests and\n<a href=\"https://ruby-lang.org\">Ruby 2.3.x</a> as its runtime.</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>If you prefer to just to look at the code, skip straight to the\n<a href=\"https://github.com/rtyler/cfp-app/blob/aff11d97b460ca4b630b1fa4f669c226aeadd8ae/Jenkinsfile\">Jenkinsfile</a>.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_preparing_the_app\"><a class=\"anchor\" href=\"#_preparing_the_app\"></a>Preparing the app</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>For <em>most</em> Rails applications there are few, if any, changes needed to enable\ncontinuous delivery with Jenkins. In the case of\n<a href=\"https://github.com/rubycentral/cfp-app\">cfp-app</a>, I added two gems to get\nthe most optimal integration into Jenkins:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p><a href=\"https://github.com/ci-reporter/ci_reporter\">ci_reporter</a>, for test report\nintegration</p>\n</li>\n<li>\n<p><a href=\"https://github.com/presidentbeef/brakeman\">brakeman</a>, for security scanning.</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>Adding these was simple, I just needed to update the <code>Gemfile</code> and the\n<code>Rakefile</code> in the root of the repository to contain:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Gemfile</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"># .. snip ..\ngroup :test do\n  # RSpec, etc\n  gem 'ci_reporter'\n  gem 'ci_reporter_rspec'\n  gem \"brakeman\", :require =&gt; false\nend</code></pre>\n</div>\n</div>\n<div class=\"listingblock\">\n<div class=\"title\">Rakefile</div>\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-ruby\" data-lang=\"ruby\"># .. snip ..\nrequire 'ci/reporter/rake/rspec'\n# Make sure we setup ci_reporter before executing our RSpec examples\ntask :spec =&gt; 'ci:setup:rspec'</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_preparing_jenkins\"><a class=\"anchor\" href=\"#_preparing_jenkins\"></a>Preparing Jenkins</h2>\n<div class=\"sectionbody\">\n<div id=\"plugins\" class=\"paragraph\">\n<p>With the cfp-app project set up, next on the list is to ensure that Jenkins itself\nis ready. Generally I suggest running the <a href=\"/changelog-stable\">latest LTS</a> of\nJenkins; for this demonstration I used Jenkins 2.7.1 with the following\nplugins:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://wiki.jenkins.io/display/JENKINS/Pipeline+Plugin\">Pipeline plugin</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.jenkins.io/display/JENKINS/Brakeman+Plugin\">Brakeman plugin</a></p>\n</li>\n<li>\n<p><a href=\"https://wiki.jenkins.io/display/JENKINS/CloudBees+Docker+Pipeline+Plugin\">CloudBees\nDocker Pipeline plugin</a></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>I also used the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/GitHub+Organization+Folder+Plugin\">GitHub\nOrganization Folder plugin</a> to automatically create pipeline items in my\nJenkins instance; that isn&#8217;t required for the demo, but it&#8217;s pretty cool to see\nrepositories and branches with a <code>Jenkinsfile</code> automatically show up in\nJenkins, so I recommend it!</p>\n</div>\n<div class=\"paragraph\">\n<p>In addition to the <a href=\"#plugins\">plugins</a> listed above, I also needed at least <em>one</em>\nJenkins agent with the <a href=\"https://docker.io\">Docker</a> daemon installed and\nrunning on it. I label these agents with \"docker\" to make it easier to assign\nDocker-based workloads to them in the future.</p>\n</div>\n<div class=\"paragraph\">\n<p>Any Linux-based machine with Docker installed will work, in my case I was\nprovisioning on-demand agents with the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/Azure+Slave+plugin\">Azure\nplugin</a> which, like the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/Amazon+EC2+Plugin\">EC2 plugin</a>,\nhelps keep my test costs down.</p>\n</div>\n<div class=\"admonitionblock tip\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Tip</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>If you&#8217;re using Amazon Web Services, you might also be interested in\n<a href=\"/blog/2016/06/10/save-costs-with-ec2-spot-fleet\">this blog post</a> from\nearlier this year unveiling the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/Amazon+EC2+Fleet+Plugin\">EC2\nFleet plugin</a> for working with EC2 Spot Fleets.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_writing_the_pipeline\"><a class=\"anchor\" href=\"#_writing_the_pipeline\"></a>Writing the Pipeline</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To make sense of the various things that the <code>Jenkinsfile</code> needs to do, I find\nit easier to start by simply defining the stages of my pipeline. This helps me\nthink of, in broad terms, what order of operations my pipeline should have.\nFor example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">/* Assign our work to an agent labelled 'docker' */\nnode('docker') {\n    stage 'Prepare Container'\n    stage 'Install Gems'\n    stage 'Prepare Database'\n    stage 'Invoke Rake'\n    stage 'Security scan'\n    stage 'Deploy'\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>As mentioned previously, this <code>Jenkinsfile</code> is going to rely heavily on the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/CloudBees+Docker+Pipeline+Plugin\">CloudBees\nDocker Pipeline plugin</a>. The plugin provides two very important features:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Ability to execute steps <em>inside</em> of a running Docker container</p>\n</li>\n<li>\n<p>Ability to run a container in the \"background.\"</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>Like most Rails applications, one can effectively test the application with two\ncommands: <code>bundle install</code> followed by <code>bundle exec rake</code>. I already had some\nDocker images prepared with <a href=\"https://rvm.io\">RVM</a> and Ruby 2.3.0 installed,\nwhich ensures a common and consistent starting point:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">node('docker') {\n    // .. 'stage' steps removed\n    docker.image('rtyler/rvm:2.3.0').inside { // <b class=\"conum\">(1)</b>\n        rvm 'bundle install' // <b class=\"conum\">(2)</b>\n        rvm 'bundle exec rake'\n    } // <b class=\"conum\">(3)</b>\n}</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>Run the named container. The <code>inside</code> method can take optional additional flags for the <code>docker run</code> command.</p>\n</li>\n<li>\n<p>Execute our shell commands using our tiny <code>sh</code> step wrapper\n<a href=\"https://github.com/rtyler/cfp-app/blob/aff11d97b460ca4b630b1fa4f669c226aeadd8ae/Jenkinsfile#L86-L91\"><code>rvm</code></a>. This ensures that the shell code is executed in the correct RVM environment.</p>\n</li>\n<li>\n<p>When the closure completes, the container will be destroyed.</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>Unfortunately, with this application, the <code>bundle exec rake</code> command will fail\nif PostgreSQL isn&#8217;t available when the process starts. This is where the\n<em>second</em> important feature of the CloudBees Docker Pipeline plugin comes\ninto effect: the ability to run a container in the \"background.\"</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">node('docker') {\n    // .. 'stage' steps removed\n    /* Pull the latest `postgres` container and run it in the background */\n    docker.image('postgres').withRun { container -&gt; // <b class=\"conum\">(1)</b>\n        echo \"PostgreSQL running in container ${container.id}\" // <b class=\"conum\">(2)</b>\n    } // <b class=\"conum\">(3)</b>\n}</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>Run the container, effectively <code>docker run postgres</code></p>\n</li>\n<li>\n<p>Any number of steps can go inside the closure</p>\n</li>\n<li>\n<p>When the closure completes, the container will be destroyed.</p>\n</li>\n</ol>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_running_the_tests\"><a class=\"anchor\" href=\"#_running_the_tests\"></a>Running the tests</h3>\n<div class=\"paragraph\">\n<p>Combining these two snippets of Jenkins Pipeline is, in my opinion, where the\npower of the <a href=\"https://en.wikipedia.org/wiki/Domain-specific_language\">DSL</a>\nshines:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">node('docker') {\n    docker.image('postgres').withRun { container -&gt;\n        docker.image('rtyler/rvm:2.3.0').inside(\"--link=${container.id}:postgres\") { // <b class=\"conum\">(1)</b>\n            stage 'Install Gems'\n            rvm \"bundle install\"\n\n            stage 'Invoke Rake'\n            withEnv(['DATABASE_URL=postgres://postgres@postgres:5432/']) { // <b class=\"conum\">(2)</b>\n                rvm \"bundle exec rake\"\n            }\n            junit 'spec/reports/*.xml' // <b class=\"conum\">(3)</b>\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>By passing the <code>--link</code> argument, the Docker daemon will allow the RVM container to talk to the PostgreSQL container under the host name 'postgres'.</p>\n</li>\n<li>\n<p>Use the <code>withEnv</code> step to set environment variables for everything that is in the closure. In this case, the cfp-app DB scaffolding will look for the <code>DATABASE_URL</code> variable to override the DB host/user/dbname defaults.</p>\n</li>\n<li>\n<p>Archive the test reports generated by <a href=\"https://github.com/ci-reporter/ci_reporter\">ci_reporter</a> so that Jenkins can display test reports and trend analysis.</p>\n</li>\n</ol>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/ruby-pipeline-2016/cfpapp-tests.png\" alt=\"cfpapp tests\">\n</div>\n</div>\n<div class=\"paragraph\">\n<p>With this done, the basics are in place to consistently run the tests for\ncfp-app in fresh Docker containers for each execution of the pipeline.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_security_scanning\"><a class=\"anchor\" href=\"#_security_scanning\"></a>Security scanning</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Using <a href=\"https://brakemanscanner.org\">Brakeman</a>, the security scanner for Ruby\non Rails, is almost trivially easy inside of Jenkins Pipeline, thanks to the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/Brakeman+Plugin\">Brakeman\nplugin</a> which implements the <code>publishBrakeman</code> step.</p>\n</div>\n<div class=\"paragraph\">\n<p>Building off our example above, we can implement the \"Security scan\" stage:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">node('docker') {\n    /* --8&lt;--8&lt;-- snipsnip --8&lt;--8&lt;-- */\n    stage 'Security scan'\n    rvm 'brakeman -o brakeman-output.tabs --no-progress --separate-models' // <b class=\"conum\">(1)</b>\n    publishBrakeman 'brakeman-output.tabs' // <b class=\"conum\">(2)</b>\n    /* --8&lt;--8&lt;-- snipsnip --8&lt;--8&lt;-- */\n}</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p>Run the <a href=\"https://brakemanscanner.org\">Brakeman</a> security scanner for Rails and store the output for later in <code>brakeman-output.tabs</code></p>\n</li>\n<li>\n<p>Archive the reports generated by Brakeman so that Jenkins can display detailed reports with trend analysis.</p>\n</li>\n</ol>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<img src=\"/images/post-images/ruby-pipeline-2016/cfpapp-brakeman.png\" alt=\"cfpapp brakeman\">\n</div>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Caution</div>\n</td>\n<td class=\"content\">\n<div class=\"paragraph\">\n<p>As of this writing, there is work in progress\n(<a href=\"https://issues.jenkins.io/browse/JENKINS-31202\">JENKINS-31202</a>) to\nrender trend graphs from plugins like Brakeman on a pipeline project&#8217;s main\npage.</p>\n</div>\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_deploying_the_good_stuff\"><a class=\"anchor\" href=\"#_deploying_the_good_stuff\"></a>Deploying the good stuff</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Once the tests and security scanning are all working properly, we can start to\nset up the deployment stage. Jenkins Pipeline provides the variable\n<code>currentBuild</code> which we can use to determine whether our pipeline has been\nsuccessful thus far or not. This allows us to add the logic to only deploy when\neverything is passing, as we would expect:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">node('docker') {\n    /* --8&lt;--8&lt;-- snipsnip --8&lt;--8&lt;-- */\n    stage 'Deploy'\n    if (currentBuild.result == 'SUCCESS') { // <b class=\"conum\">(1)</b>\n        sh './deploy.sh' // <b class=\"conum\">(2)</b>\n    }\n    else {\n        mail subject: \"Something is wrong with ${env.JOB_NAME} ${env.BUILD_ID}\",\n                  to: 'nobody@example.com',\n                body: 'You should fix it'\n    }\n    /* --8&lt;--8&lt;-- snipsnip --8&lt;--8&lt;-- */\n}</code></pre>\n</div>\n</div>\n<div class=\"colist arabic\">\n<ol>\n<li>\n<p><code>currentBuild</code> has the <code>result</code> property which would be <code>'SUCCESS'</code>, <code>'FAILED'</code>, <code>'UNSTABLE'</code>, <code>'ABORTED'</code></p>\n</li>\n<li>\n<p>Only if <code>currentBuild.result</code> is successful should we bother invoking our deployment script (e.g. <code>git push heroku master</code>)</p>\n</li>\n</ol>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_wrap_up\"><a class=\"anchor\" href=\"#_wrap_up\"></a>Wrap up</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>I have gratuitously commented the full\n<a href=\"https://github.com/rtyler/cfp-app/blob/0e85db6d054deefd637de235766468631f551c7f/Jenkinsfile\">Jenkinsfile</a>\nwhich I hope is a useful summation of the work outlined above. Having worked\non a number of Rails applications in the past, the consistency provided by\nDocker and Jenkins Pipeline above would have definitely improved those\nprojects' delivery times. There is still room for improvement however, which\nis left as an exercise for the reader. Such as: preparing new containers with\nall their\n<a href=\"https://github.com/rtyler/cfp-app/blob/0e85db6d054deefd637de235766468631f551c7f/Jenkinsfile#L36-L46\">dependencies\nbuilt-in</a> instead of installing them at run-time. Or utilizing the <code>parallel</code>\nstep for executing RSpec across multiple Jenkins agents simultaneously.</p>\n</div>\n<div class=\"paragraph\">\n<p>The beautiful thing about defining your continuous delivery, and continuous\nsecurity, pipeline in code is that you can continue to iterate on it!</p>\n</div>\n<div class=\"imageblock center\">\n<div class=\"content\">\n<a class=\"image\" href=\"https://github.com/rtyler/cfp-app/blob/0e85db6d054deefd637de235766468631f551c7f/Jenkinsfile\"><img src=\"/images/post-images/ruby-pipeline-2016/cfpapp-stage-view.png\" alt=\"cfpapp stage view\"></a>\n</div>\n</div>\n</div>\n</div>","document":{"title":"Continuous Security for Rails apps with Pipeline and Brakeman","main":"Continuous Security for Rails apps with Pipeline and Brakeman"},"author":{"fullName":"tags:"}}},"pageContext":{"id":"dfa4f363-f1df-5f98-9d93-a2d2d93b2e6c"}},"staticQueryHashes":[],"slicesMap":{}}