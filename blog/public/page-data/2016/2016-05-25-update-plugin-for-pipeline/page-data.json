{"componentChunkName":"component---src-templates-article-js","path":"/2016/2016-05-25-update-plugin-for-pipeline/","result":{"data":{"asciidoc":{"html":"<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nThis is a guest post by <a href=\"https://github.com/cprice404\">Chris Price</a>.\nChris is a software engineer at <a href=\"https://puppet.com\">Puppet</a>, and has been\nspending some time lately on automating performance testing using the latest\nJenkins features.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>In this blog post, I&#8217;m going to attempt to provide some step-by-step notes on\nhow to refactor an existing Jenkins plugin to make it compatible with the new\nJenkins Pipeline jobs.  Before we get to the fun stuff, though, a little\nbackground.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_howd_i_end_up_here\">How&#8217;d I end up here?</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Recently, I started working on a project to automate some performance tests for\nmy company&#8217;s products.  We use the awesome <a href=\"https://gatling.io/#/\">Gatling</a> load\ntesting tool for these tests, but we&#8217;ve largely been handling the testing very\nmanually to date, due to a lack of bandwidth to get them automated in a clean,\nmaintainable, extensible way.  We have a years-old Jenkins server where we use\nthe <a href=\"https://wiki.jenkins.io/display/JENKINS/Gatling+Plugin\">gatling jenkins\nplugin</a> to track the\nhistory of certain tests over time, but the setup of the Jenkins instance was\nvery delicate and not easy to reproduce, so it had fallen into a state of\ndisrepair.</p>\n</div>\n<div class=\"paragraph\">\n<p>Over the last few days I&#8217;ve been putting some effort into getting things more\nautomated and repeatable so that we can really maximize the value that we&#8217;re\ngetting out of the performance tests.  With some encouragement from the fine\nfolks in the <code>#jenkins</code> <a href=\"/content/chat\">IRC channel</a>, I ended up exploring\nthe <a href=\"https://wiki.jenkins.io/display/JENKINS/Job+DSL+Plugin\">JobDSL\nplugin</a> and the new <a href=\"/doc/pipeline\">Pipeline jobs</a>.  Combining those two\nthings with some Puppet code to provision a Jenkins server via the\n<a href=\"https://github.com/jenkinsci/puppet-jenkins\">jenkins puppet module</a> gave me\na really nice way to completely automate my Jenkins setup and get a seed job in\nplace that would create my perf testing jobs.  And the Pipeline job format is\njust an <strong>awesome</strong> fit for what I wanted to do in terms of being able to easily\nmonitor the stages of my performance tests, and to make the job definitions\nmodular so that it would be really easy to create new performance testing jobs\nwith slight variations.</p>\n</div>\n<div class=\"paragraph\">\n<p>So everything&#8217;s going GREAT up to this point.  I&#8217;m really happy with how it&#8217;s\nall shaping up.  But then&#8230;&#8203; (you knew there was a \"but\" coming, right?) I\nstarted trying to figure out how to add the\n<a href=\"https://wiki.jenkins.io/display/JENKINS/Gatling+Plugin\">Gatling Jenkins\nplugin</a> to the Pipeline jobs, and kind of ran into a wall.</p>\n</div>\n<div class=\"paragraph\">\n<p>As best as I could tell from my Googling, the plugin was probably going to\nrequire some modifications in order to be able to be used with Pipeline jobs.\nHowever, I wasn&#8217;t able to find any really cohesive documentation that\ndefinitively confirmed that or explained how everything fits together.</p>\n</div>\n<div class=\"paragraph\">\n<p>Eventually, I got it all sorted out.  So, in hopes of saving the next person a\nlittle time, and encouraging plugin authors to invest the time to get their\nplugins working with Pipeline, here are some notes about what I learned.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>Spoiler:</strong> if you&#8217;re just interested in looking at the individual git commits that\nI made on may way to getting the plugin working with Pipeline, have a look at\n<a href=\"https://github.com/cprice404/gatling-plugin/commits/feature/master/compatibility-with-jenkins-pipeline.individual-commits\">this github\nbranch</a>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_creating_a_pipeline_step\">Creating a pipeline step</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The main task that the Gatling plugin performs is to archive Gatling reports\nafter a run.  I figured that the end game for this exercise was that I was going\nto end up with a Pipeline \"step\" that I could include in my Pipeline scripts, to\ntrigger the archiving of the reports.  So my first thought was to look for an\nexisting plugin / Pipeline \"step\" that was doing something roughly similar, so\nthat I could use it as a model.  The Pipeline \"Snippet Generator\" feature\n(create a pipeline job, scroll down to the \"Definition\" section of its\nconfiguration, and check the \"Snippet Generator\" checkbox) is really helpful for\nfiguring out stuff like this; it is automatically populated with all of the\nsteps that are valid on your server (based on which plugins you have installed),\nso you can use it to verify whether or not your custom \"step\" is recognized, and\nalso to look at examples of existing steps.</p>\n</div>\n<div class=\"paragraph\">\n<p>Looking through the list of existing steps, I figured that the <code>archive</code> step\nwas pretty likely to be similar to what I needed for the gatling plugin:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/post-images/update-plugin-for-pipeline-tutorial/05_snippet_generator_archive.png\" alt=\"archive snippet\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>So, I started poking around to see what magic it was that made that <code>archive</code>\nstep show up there.  There are some mentions of this in the\n<a href=\"https://github.com/jenkinsci/pipeline-plugin/blob/6cffbecd874b924677ce3b3c5b1e0e2f45689cc5/DEVGUIDE.md#build-steps\">pipeline-plugin\nDEVGUIDE.md</a> and the\n<a href=\"https://github.com/jenkinsci/workflow-step-api-plugin/blob/ee8f181c5561d70207a6b84b4d91ca24312c8a39/README.md\">workflow-step-api-plugin\nREADME.md</a>, but the real breakthrough for me was finding the <a href=\"https://github.com/jenkinsci/workflow-basic-steps-plugin/blob/300fe6c02b41f072e50a501cfec3e2f425048446/src/main/java/org/jenkinsci/plugins/workflow/steps/ArtifactArchiverStep.java#L37-L53\">definition of the\n<code>archive</code> step in the <code>workflow-basic-steps-plugin</code> source\ncode</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>With that as an example, I was able to start poking at getting a\n<code>gatlingArchive</code> step to show up in the Snippet Generator.  The first thing that\nI needed to do was to <a href=\"https://github.com/cprice404/gatling-plugin/commit/b321192bc635eee529ff70e4795591c4594f3664\">update the <code>gatling-plugin</code> project&#8217;s <code>pom.xml</code> to depend\non a recent enough version of Jenkins, as well as specify dependencies on the\nappropriate pipeline\nplugins</a></p>\n</div>\n<div class=\"paragraph\">\n<p>Once that was out of the way, I noticed that the <code>archive</code> step had some tests\nwritten for it, using what looks to be a pretty awesome test API for pipeline\njobs and plugins.  Based on <a href=\"https://github.com/jenkinsci/workflow-basic-steps-plugin/blob/300fe6c02b41f072e50a501cfec3e2f425048446/src/test/java/org/jenkinsci/plugins/workflow/steps/ArtifactArchiverStepTest.java#L26-L44\">those <code>archive</code>\ntests</a>,\nI added\n<a href=\"https://github.com/cprice404/gatling-plugin/commit/ed9df4b54c36cee467b3a82e42cb2111e93f9df5\">a\nskeleton for a test for the <code>gatlingArchive</code> step</a> that I was about to write.</p>\n</div>\n<div class=\"paragraph\">\n<p>Then, I moved on to\n<a href=\"https://github.com/cprice404/gatling-plugin/commit/3de3485be591c7b750ec2671e74558a79efc4319\">actually\ncreating the step</a>.  The meat of the code was this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class GatlingArchiverStep extends AbstractStepImpl {\n    @DataBoundConstructor\n    public GatlingArchiverStep() {}\n\n    @Extension\n    public static class DescriptorImpl extends AbstractStepDescriptorImpl {\n        public DescriptorImpl() { super(GatlingArchiverStepExecution.class); }\n\n        @Override\n        public String getFunctionName() {\n            return \"gatlingArchive\";\n        }\n\n        @NonNull\n        @Override\n        public String getDisplayName() {\n            return \"Archive Gatling reports\";\n        }\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Note that in that commit I also added a <code>config.jelly</code> file.  This is how you\ndefine the UI for your step, which will show up in the Snippet Generator.  In\nthe case of this Gatling step there&#8217;s really not much to configure, so my\n<code>config.jelly</code> is basically empty.</p>\n</div>\n<div class=\"paragraph\">\n<p>With that (and the rest of the code from that commit) in place, I was able to\nfire up the development Jenkins server (via <code>mvn hpi:run</code>, and note that you\nneed to go into the \"Manage Plugins\" screen on your development server and\ninstall the Pipeline plugin once before any of this will work) and visit the\nSnippet Generator to see if my step showed up in the dropdown:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/post-images/update-plugin-for-pipeline-tutorial/10_snippet_generator.png\" alt=\"gatlingArchive snippet\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>GREAT SUCCESS!</p>\n</div>\n<div class=\"paragraph\">\n<p>This step doesn&#8217;t actually <strong>do</strong> anything yet, but it&#8217;s recognized by Jenkins and\ncan be included in your pipeline scripts at that point, so, we&#8217;re on our way!</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_the_step_metastep\">The <code>step</code> metastep</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The step that we created above is a first-class DSL addition that can be used in\nPipeline scripts.  There&#8217;s another way to make your plugin work usable from a\nPipeline job, without making it a first-class build step.  This is by use of the\n<code>step</code> \"metastep\", mentioned in the <a href=\"https://github.com/jenkinsci/pipeline-plugin/blob/893e3484a25289c59567c6724f7ce19e3d23c6ee/DEVGUIDE.md#build-steps\">pipeline-plugin\nDEVGUIDE</a>.\nWhen using this approach, you simply refactor your <code>Builder</code> or <code>Publisher</code> to\nextend <code>SimpleBuildStep</code>, and then you can reference the build step from the\nPipeline DSL using the <code>step</code> method.</p>\n</div>\n<div class=\"paragraph\">\n<p>In the Jenkins GUI, go to the config screen for a Pipeline job and click on the\nSnippet Generator checkbox.  Select 'step: General Build Step' from the\ndropdown, and then have a look at the options that appear in the 'Build Step'\ndropdown.  To compare with our previous work, let&#8217;s see what \"Archive the\nartifacts\" looks like:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/post-images/update-plugin-for-pipeline-tutorial/15_archive_metastep_snippet.png\" alt=\"archive metastep plugin\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>From the snippet generator we can see that it&#8217;s possible to trigger an Archive\naction with syntax like:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">step([$class: 'ArtifactArchiver', artifacts: 'foo*', excludes: null])</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This is the \"metastep\".  It&#8217;s a way to trigger any build action that implements\n<code>SimpleBuildStep</code>, without having to actually implement a real \"step\" that\nextends the Pipeline DSL like we did above.  In many cases, it might only make\nsense to do one or the other in your plugin; you probably don&#8217;t really need\nboth.</p>\n</div>\n<div class=\"paragraph\">\n<p>For the purposes of this tutorial, we&#8217;re going to do both.  For a couple of reasons:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Why the heck not?  :)  It&#8217;s a good demonstration of how the metastep stuff\nworks.</p>\n</li>\n<li>\n<p>Because implementing the \"for realz\" step will be a lot easier if the Gatling\naction that we&#8217;re trying to call from our <code>gatlingArchive()</code> syntax is using the\nnewer Jenkins APIs that are required for subclasses of <code>SimpleBuildStep</code>.</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p><code>GatlingPublisher</code> is the main build action that we&#8217;re interested in using in\nPipeline jobs.  So, with all of that in mind, here&#8217;s our next goal: get\n<code>step([$class: 'GatlingPublisher', &#8230;&#8203;)</code> showing up in the Snippet Generator.</p>\n</div>\n<div class=\"paragraph\">\n<p>The <a href=\"https://github.com/jenkinsci/jenkins/blob/jenkins-1.651.2/core/src/main/java/jenkins/tasks/SimpleBuildStep.java#L51-L66\">javadocs for the SimpleBuildStep\nclass</a>\nhave some notes on what you need to do when porting an existing <code>Builder</code> or\n<code>Publisher</code> over to implement the <code>SimpleBuildStep</code> interface.  In all\nlikelihood, most of what you&#8217;re going to end up doing is to replace occurrences\nof <code>AbstractBuild</code> with references to the <code>Run</code> class, and replace occurrences\nof <code>AbstractProject</code> with references to the <code>Job</code> class.  The APIs are pretty\nsimilar, so it&#8217;s not too hard to do once you understand that that&#8217;s the game.\nThere is some discussion of this in the <a href=\"https://github.com/jenkinsci/pipeline-plugin/blob/893e3484a25289c59567c6724f7ce19e3d23c6ee/DEVGUIDE.md#historical-background\">pipeline-plugin\nDEVGUIDE</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>For the Gatling plugin, my\n<a href=\"https://github.com/cprice404/gatling-plugin/commit/288041c696840ea8eaf21705caf756d3d4bb1f94\">initial\nefforts to port the <code>GatlingPublisher</code> over to implement <code>SimpleBuildStep</code></a> only\nrequired the <code>AbstractBuild</code> &#8594; <code>Run</code> refactor.</p>\n</div>\n<div class=\"paragraph\">\n<p>After making these changes, I fired up the development Jenkins server, and, voila!</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/post-images/update-plugin-for-pipeline-tutorial/20_gatling_metastep_snippet.png\" alt=\"gatling metastep snippet\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>So, now, we can add a line like this to a Pipeline build script:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">step([$class: 'GatlingPublisher', enabled: true])</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>And it&#8217;ll effectively be the same as if we&#8217;d added the Gatling \"Post-Build\nAction\" to an old-school Freestyle project.</p>\n</div>\n<div class=\"paragraph\">\n<p>Well&#8230;&#8203; mostly.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_build_actions_vs_project_actions\">Build Actions vs. Project Actions</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>At this point our modified Gatling plugin should work the same way as it always\ndid in a Freestyle build, but in a Pipeline build, it only partially works.\nSpecifically, the Gatling plugin implements two different \"Actions\" to surface\nthings in the Jenkins GUI: a \"Build\" action, which adds the Gatling icon to the\nleft sidebar in the GUI when you&#8217;re viewing an individual build in the build\nhistory of a job, and a \"Project\" action, which adds that same icon to the left\nsidebar of the GUI of the main page for a job.  The \"Project\" action also adds a\n\"floating panel\" on the main job page, which shows a graph of the historical\ndata for the Gatling runs.</p>\n</div>\n<div class=\"paragraph\">\n<p>In a Pipeline job, though, assuming we&#8217;ve added a call to the metastep, we&#8217;re\nonly seeing the \"Build\" actions.  Part of this is because, in the last round of\nchanges that I linked, we only modified the \"Build\" action, and not the\n\"Project\" action.  Running the metastep in a Pipeline job has no visible effect\nat all on the project/job page at this point.  So that&#8217;s what we&#8217;ll tackle next.</p>\n</div>\n<div class=\"paragraph\">\n<p>The key thing to know about getting \"Project\" actions working in a Pipeline job\nis that, with a Pipeline job, there is no way for Jenkins to know up front what\nsteps or actions are going to be involved in a job.  It&#8217;s only after the job\nruns once that Jenkins has a chance to introspect what all the steps were.  As\nsuch, there&#8217;s no list of Builders or Publishers that it knows about up front to\ncall <code>getProjectAction</code> on, like it would with a Freestyle job.</p>\n</div>\n<div class=\"paragraph\">\n<p>This is where\n<a href=\"https://github.com/jenkinsci/jenkins/blob/jenkins-1.651.2/core/src/main/java/jenkins/tasks/SimpleBuildStep.java#L81-L97\"><code>SimpleBuildStep.LastBuildAction</code></a>\ncomes into play.  This is an interface that you can add to your Build actions,\nwhich give them their own <code>getProjectActions</code> method that Jenkins recognizes and\nwill call when rendering the project page after the job has been run at least\nonce.</p>\n</div>\n<div class=\"paragraph\">\n<p>So, effectively, what we need to do is to\n<a href=\"https://github.com/cprice404/gatling-plugin/commit/34d811add49ba7f07149a70000c380aadd2407bc\">get\nrid of the <code>getProjectAction</code> method on our <code>Publisher</code> class, modify the Build\naction to implement <code>SimpleBuildStep.LastBuildAction</code>, and encapsulate our\nProject action instances in the Build action</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The build action class now constructs an instance of the Project action and\nmakes it accessible via <code>getProjectActions</code> (which comes from the\n<code>LastBuildAction</code> interface):</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class GatlingBuildAction implements Action, SimpleBuildStep.LastBuildAction {\n    public GatlingBuildAction(Run&lt;?, ?&gt; build, List&lt;BuildSimulation&gt; sims) {\n        this.build = build;\n        this.simulations = sims;\n\n        List&lt;GatlingProjectAction&gt; projectActions = new ArrayList&lt;&gt;();\n        projectActions.add(new GatlingProjectAction(build.getParent()));\n        this.projectActions = projectActions;\n    }\n\n    @Override\n    public Collection&lt;? extends Action&gt; getProjectActions() {\n        return this.projectActions;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>After making these changes, if we run the development Jenkins server, we can see\nthat after the first successful run of the Pipeline job that calls the\n<code>GatlingPublisher</code> metastep, the Gatling icon indeed shows up in the sidebar on\nthe main project page, and the floating box with the graph shows up as well:</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image center\"><img src=\"/post-images/update-plugin-for-pipeline-tutorial/25_gatling_project_page.png\" alt=\"gatling project page\"></span></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_making_our_dsl_step_do_something\">Making our DSL step do something</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>So at this point we&#8217;ve got the metastep syntax working from end-to-end, and\nwe&#8217;ve got a valid Pipeline DSL step (<code>gatlingArchive()</code>) that we can use in our\nPipeline scripts without breaking anything&#8230;&#8203; but our custom step doesn&#8217;t\nactually do anything.  Here&#8217;s the part where we tie it all together&#8230;&#8203; and it&#8217;s\npretty easy!  All we need to do is to <a href=\"https://github.com/cprice404/gatling-plugin/commit/d81229f86a8e3cb0a0496ed2c71b6b94f4707720\">make our step \"Execution\" class\ninstantiate a Publisher and call <code>perform</code> on\nit</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>As per the\n<a href=\"https://github.com/jenkinsci/pipeline-plugin/blob/893e3484a25289c59567c6724f7ce19e3d23c6ee/DEVGUIDE.md#variable-substitutions\">notes\nin the pipeline-plugin DEVGUIDE</a>, we can use the <code>@StepContextParameter</code>\nannotation to inject in the objects that we need to pass to the Publisher&#8217;s\n<code>perform</code> method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">public class GatlingArchiverStepExecution extends AbstractSynchronousNonBlockingStepExecution&lt;Void&gt; {\n\n    @StepContextParameter\n    private transient TaskListener listener;\n\n    @StepContextParameter\n    private transient FilePath ws;\n\n    @StepContextParameter\n    private transient Run build;\n\n    @StepContextParameter\n    private transient Launcher launcher;\n\n    @Override\n    protected Void run() throws Exception {\n        listener.getLogger().println(\"Running Gatling archiver step.\");\n\n        GatlingPublisher publisher = new GatlingPublisher(true);\n        publisher.perform(build, ws, launcher, listener);\n\n        return null;\n    }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>After these changes, we can fire up the development Jenkins server, and hack up\nour Pipeline script to call <code>gatlingArchive()</code> instead of the metastep\n<code>step([$class: 'GatlingPublisher', enabled: true])</code> syntax.  One of these is\nnicer to type and read than the other, but I&#8217;ll leave that as an exercise for\nthe reader.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_fin\">Fin</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>With that, our plugin now works just as well in the brave new Pipeline world as\nit did in the olden days of Freestyle builds.  I hope these notes save someone\nelse a little bit of time and googling on your way to writing (or porting) an\nawesome plugin for Jenkins Pipeline jobs!</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_links\">Links</h2>\n<div class=\"sectionbody\">\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"/solutions/pipeline/\">Jenkins Pipeline Overview</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/jenkinsci/pipeline-plugin/blob/master/DEVGUIDE.md\">Pipeline Plugin Developer Guide</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/jenkinsci/jenkins\">Jenkins Source Code</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/jenkinsci/workflow-step-api-plugin\">Workflow Step API Plugin</a></p>\n</li>\n<li>\n<p><a href=\"https://github.com/jenkinsci/workflow-basic-steps-plugin\">Workflow Basic Steps Plugin</a></p>\n</li>\n</ul>\n</div>\n</div>\n</div>","document":{"title":"Refactoring a Jenkins plugin for compatibility with Pipeline jobs","main":"Refactoring a Jenkins plugin for compatibility with Pipeline jobs"},"author":{"fullName":"::page-tags: core, pipeline, plugins"},"pageAttributes":{"author":"cprice404","tags":null,"opengraph":null}}},"pageContext":{"id":"577647da-31dd-5d1a-8240-8469709da705"}},"staticQueryHashes":[],"slicesMap":{}}