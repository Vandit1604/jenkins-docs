{"componentChunkName":"component---src-templates-article-js","path":"/2023/04/07/2023-04-07-android-and-jenkins-discovery/","result":{"data":{"asciidoc":{"html":"<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>discourse: true\n---</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image\"><img src=\"/post-images/2023/04/07/2023-04-07-android-and-jenkins-discovery/profile_of_cicd_users.png\" alt=\"profile of ci/cd users\" width=\"found on www.developernation.net/blog/devops-ci-cd-usage-trends\"></span></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_why_is_mobile_cicd_special\">Why is mobile CI/CD special?</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>In 2020, a surprising <a href=\"https://www.developernation.net/blog/devops-ci-cd-usage-trends\">33% of professional mobile app developers</a> were not using Continuous Integration/Continuous Deployment (CI/CD) practices, which is 18% more than web developers.\nThere are several reasons why this is the case:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Unique needs: Unlike web applications, mobile applications have different requirements, which means that mobile CI/CD requires a different approach and dedicated tools.</p>\n</li>\n<li>\n<p>Tightly controlled ecosystems: Unlike the open ecosystem of the web, mobile app ecosystems are tightly controlled by the OS providers, such as Apple and Google.\nThese providers have strict rules from development to deployment, to running the apps.\nAs a result, traditional CI/CD approaches and best practices can&#8217;t be applied out of the box.</p>\n</li>\n<li>\n<p>Specialized expertise is required: Mobile CI/CD requires specific expertise that may not be available in the typical DevOps team.\nIn many cases, mobile developers must handle the mobile CI/CD pipeline themselves due to the unique requirements.\nHowever, it is still CI/CD and requires that specific mindset, along with mobility knowledge.</p>\n</li>\n<li>\n<p>Mobile CI/CD requires a separate pipeline: Mobile CI/CD requires setting up a separate pipeline from web or backend stacks, as it is based on the deployment of a compiled binary, which has to be installed on a mobile device from scratch every time.\nEnd-user deployments for B2C apps are subject to app reviews and app release waiting periods, which is not prevalent in other stacks.\nAs a result, errors should be detected at the earliest stage (the famous \"shift-left\") and mobile-app-specific code analyses and tests should be incorporated at every step of CI/CD to avoid issues being discovered by the end-user.</p>\n</li>\n<li>\n<p>Code-signing is mandatory: Unlike most other stacks, code-signing is mandatory in mobile app development.\nThis introduces another layer of complexity on top of the already complex mobile CI/CD processes.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>In summary, mobile app development requires unique CI/CD practices, due to the specific needs of the mobile app ecosystem, the specialized expertise required, and the need for a separate pipeline for deployment.\nBy understanding and addressing these challenges, mobile app developers can successfully adopt CI/CD practices and ensure the delivery of high-quality mobile apps.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_how_do_we_progress_then\">How do we progress then?</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Mobile app development requires dedicated tools and approaches for CI/CD management.\nHowever, in many cases, mobile developers themselves are tasked with managing CI/CD, which is not their core role.\nThis can result in significant time and productivity losses.</p>\n</div>\n<div class=\"paragraph\">\n<p>To optimize mobile CI/CD management, it is essential to have a dedicated team member who is knowledgeable in both mobile development and CI/CD.\nIdeally, this person would have experience as a former mobile app developer who has transitioned into a CI/CD role.\nAlternatively, someone who knows CI/CD and wants to help mobile app developers onboard the CI/CD train can also be valuable.</p>\n</div>\n<div class=\"paragraph\">\n<p>In conclusion, by having dedicated team members who are knowledgeable in both mobile development and CI/CD, and by utilizing effective tools and approaches, mobile CI/CD management can be optimized to improve productivity and minimize time losses.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_flashback_to_my_previous_job\">Flashback to my previous job</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>At my previous job, we evolved our mobile CI/CD system over time and ended up using Gitlab-ci, along with a set of specific Docker images.\nOur standard image contained the latest version of all the required tools, including maven, ant, gradle, android SDK, android NDK, flutter, firebase, linters, and dependency checkers.\nThis image was cached on the <a href=\"https://bruno.verachten.fr/2021/01/11/Arm-your-ci-with-fruits/\">runners</a>, similar to <a href=\"/doc/book/using/using-agents/\">Jenkins agents</a>, so that jobs could start immediately.</p>\n</div>\n<div class=\"paragraph\">\n<p>We also created specific images with various versions of the tools or with specific tools added.\nAdditionally, we linked an <a href=\"https://github.com/DeviceFarmer/stf#readme\">Android Device Farm</a> to Gitlab-ci, so that developers could test their newly built app on real Android devices directly from their pipeline.</p>\n</div>\n<div class=\"paragraph\">\n<p>In 2022, I resigned from my previous job and started working at CloudBees.\nSoon after, my manager asked if I would be interested in replicating some of the work I had done with GitLab-CI, but this time using Jenkins.\nI was intrigued and asked two questions.\nFirst, does Jenkins work well with Docker (to which I got an honest \"sort of\" answer), and second, whether I could start from scratch without looking at what had worked for Android app development with Jenkins previously.\nMy goal was relying instead on my old GitLab habits, even if that meant failure.\nTo my surprise, my manager said, \"Go for it,\" and I began my journey to experiment, learn, and share my findings.</p>\n</div>\n<div class=\"paragraph\">\n<p>Given my more than 8 years of experience with Mobile App CI/CD, I initially thought this would be a cakewalk.\nBut it turned out to be quite the ride&#8230;&#8203;</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_starting_with_jenkins\">Starting with Jenkins</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>I embarked on a new journey with Jenkins, despite having no prior experience with the tool.\nAs a result, I made every mistake a Jenkins newbie could possibly make.\nTo begin my learning process, I knew that starting with an empty Android application was the logical first step.\nHowever, as the saying goes, it&#8217;s difficult to teach an old monkey new tricks.\nTherefore, I decided to dive headfirst into rebuilding an Android Docker image, attempting to fit in all the tools I could think of, much like I had done previously with Gitlab.</p>\n</div>\n<div class=\"paragraph\">\n<p>In my naivete, I believed that once I pushed the image to <a href=\"https://hub.docker.com/repositories/gounthar\">DockerHub</a>, Jenkins would somehow magically use it for my builds, and I would be done in a matter of days.\nLooking back, it&#8217;s almost endearing to see how naive I was.\nSimultaneously, I installed Jenkins through <a href=\"/doc/book/installing/docker/#on-windows\">Docker on my Windows laptop</a> and experimented with a few tutorials, starting with the simplest jobs possible that worked.</p>\n</div>\n<div class=\"paragraph\">\n<p>After successfully pushing my bulky Docker image, filled with all the necessary tools, I moved onto creating an empty Android application, with plans to connect the dots later on.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_android_app\">Android app</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>To start, I created a <a href=\"https://github.com/gounthar/MyFirstAndroidAppBuiltByJenkins\">new repository</a> on GitHub and cloned it onto my laptop.\nFrom there, I opened up Android Studio and created a brand new application from scratch within that folder.\nOnce I had everything set up, I committed and pushed the app shell to GitHub.</p>\n</div>\n<div class=\"paragraph\">\n<p>To make sure the application could be built outside of my machine, I added a <a href=\"https://github.com/gounthar/MyFirstAndroidAppBuiltByJenkins/blob/main/.github/workflows/android.yml\">GitHub Action file</a>.\nThankfully, building a simple Android app is possible with GitHub Actions, as they provide Java and Android SDK in their <a href=\"https://github.com/actions/runner-images#available-images\">Ubuntu:latest image</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>With this setup, my empty app could be built on Android Studio <em>and</em> with GitHub Actions.\nAs a result, I was able to obtain my APKs on both platforms.\nIt was a satisfying milestone to achieve.</p>\n</div>\n<div class=\"paragraph\">\n<p>Following the official documentation, I managed to install both the Jenkins controller and <a href=\"/doc/book/using/using-agents/#on-windows\">agent</a>.\nHowever, as a beginner, I found the process unnecessarily complex.\nDespite successfully running a Jenkins controller and agent on Docker images on my laptop, I encountered difficulties when trying to run my custom Android building Docker image on it.</p>\n</div>\n<div class=\"paragraph\">\n<p>Now I understand that there were other ways to approach the problem, but at the time, I was determined to stick with my old habits.\nI knew that creating a specific agent by starting with the <a href=\"https://github.com/jenkinsci/docker-ssh-agent\">SSH agent Docker image</a> and adding the <a href=\"https://developer.android.com/studio\">Android SDK</a> was an option, but I was more comfortable using my custom Docker image and generic agents.\nAs the saying goes, \"when your only tool is a hammer, everything looks like a nail\".</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_the_free_tier_parenthesis\">The Free Tier parenthesis</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Unfortunately, I ran into some issues with running my custom Docker image under Windows.\nSo, I decided to create two Jenkins agents on <a href=\"https://www.oracle.com/fr/cloud/free/\">Oracle Cloud Free Tier</a> machines instead.\nI installed Java and Docker on these machines, and then created a Jenkins agent that was <a href=\"/blog/2022/12/27/run-jenkins-agent-as-a-service/\">handled by systemd</a>.\nThis allowed me to continue working on my project and explore different ways of using Jenkins.</p>\n</div>\n<div class=\"paragraph\">\n<p>One of the Free Tier machines on <a href=\"https://docs.oracle.com/en-us/iaas/Content/FreeTier/freetier.htm\">Oracle Cloud</a> was set up with the Android SDK so that it could handle Android jobs, earning it the moniker \"JenkinsDroid\".\nUsing this machine, I created a simple Android job on Jenkins that referenced my GitHub repository and initiated the build process.</p>\n</div>\n<div class=\"paragraph\">\n<p>As I gained confidence, I added more checks and bundle creation, and soon found myself with a long list of build steps in a <a href=\"https://phoenixnap.com/kb/jenkins-build-freestyle-project#:~:text=tutorial%20for%20beginners.-,What%20is%20a%20Jenkins%20Freestyle%20Project%3F,steps%20and%20post%2Dbuild%20actions.\">FreeStyle project</a>.\nHowever, I realized that if the Jenkins controller were to restart for any reason, my current builds would be lost.\nThis was a major drawback, and I wanted to find a more robust solution.</p>\n</div>\n<div class=\"paragraph\">\n<p>After some research, I discovered that <a href=\"/doc/pipeline/tour/hello-world/#what-is-a-jenkins-pipeline\">pipeline jobs</a> are not affected by the controller restart issue.\nAs a result, I decided to switch to pipeline jobs to ensure that my builds would be safe even if the controller restarted.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_from_freestyle_to_pipeline\">From FreeStyle to Pipeline</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>As a developer, I often try to find ways to make my work easier.\nAdmittedly, I can be a bit lazy when it comes to certain tasks.\nThat&#8217;s why I decided to use the <a href=\"https://plugins.jenkins.io/declarative-pipeline-migration-assistant-api/\">Declarative Pipeline Migration Assistant</a> to convert my FreeStyle project into a Pipeline project.\nHowever, my first attempt at using this converted pipeline failed due to incorrect syntax.\nIt was back to the drawing board for me, and I had to learn the <a href=\"/doc/book/pipeline/syntax/\">Declarative Pipeline syntax</a>.\nRemember the old Apple ads from around 2009, where the answer to every need was \"there&#8217;s an app for that\"?\nIn the same way, Jenkins has a solution for almost every need.\nOne thing I appreciate about Jenkins is that it offers a lot of flexibility regardless of the version being used.</p>\n</div>\n<div class=\"paragraph\">\n<p>Jenkins is an incredibly powerful tool, with a vast community contributing to its <a href=\"https://plugins.jenkins.io/\">plugins</a>.\nWith over <a href=\"https://stats.jenkins.io/jenkins-stats/svg/svgs.html\">2,000 plugins available</a>, it&#8217;s safe to say that if you have a need, there&#8217;s likely a plugin that can help you achieve it.\nHowever, with so many options available, it can sometimes be overwhelming to choose the right one.\nIt&#8217;s important to note that some plugins may be outdated or incompatible with your Java or Jenkins version, so it&#8217;s always wise to double-check compatibility before installing.\nDespite these potential challenges, the sheer number of available plugins is a testament to the versatility and flexibility of Jenkins.</p>\n</div>\n<div class=\"paragraph\">\n<p><span class=\"image\"><img src=\"/post-images/2023/04/07/2023-04-07-android-and-jenkins-discovery/2023-03_plugins.png\" alt=\"History of the number of plugins since 2008 to March 2023\" width=\"839\"></span></p>\n</div>\n<div class=\"paragraph\">\n<p>To start with, I began with a small Pipeline description, gradually expanding it to incorporate more stages, additional tools, <a href=\"https://www.perforce.com/blog/sca/what-static-analysis\">static analysis</a>, compilation, unit testing, and ultimately, the creation of the release, which we will explore in a few weeks.\nHowever, the worst possible thing happened: I lost everything.</p>\n</div>\n<div class=\"paragraph\">\n<p>As previously mentioned, my Jenkins controller instance was running on my Windows machine, running atop Docker.\nOne day, as I was trying to free up space for Android builds, I unintentionally entered a Docker command that removed all volumes, resulting in the loss of my jobs and their respective definitions.</p>\n</div>\n<div class=\"paragraph\">\n<p>Despite taking precautions, things can still go wrong.\nIt was frustrating, but I learned from it and decided to store my Jenkinsfile in GitHub along with my other files, which gave me a sense of familiarity since GitLab-ci uses a similar approach.\nWith Jenkins, I could create a separate Pipeline for each branch with different agents, different Docker images, and different tools, which was very convenient.\nHowever, it&#8217;s not perfect since a branch&#8217;s last commit/push is always used to start a job, and it&#8217;s impossible to build a specific branch explicitly.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_using_a_simple_pipeline_with_multi_branches\">Using a simple Pipeline with multi branches</h2>\n<div class=\"sectionbody\">\n\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_status\">Status</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Let&#8217;s face it, unexpected issues can occur during a build.\nWhile it is ideal to have everything reproducible at the click of a button, in the real world, a machine serving dependencies can go down, a link can break momentarily, or a docker image layer can go missing.\nWhen using <a href=\"/doc/book/pipeline/docker/#dockerfile\"><code>dockerfile: true</code></a>, the risks are even higher, as you&#8217;re building the tool you&#8217;ll be using for the build, and sometimes things can go out of control.</p>\n</div>\n<div class=\"paragraph\">\n<p>When a build fails due to missing dependencies on <code>Branch A</code>, but a build on <code>Branch B</code> starts because it&#8217;s the latest commit/push, what can you do?\nIt&#8217;s not a good idea to keep a simple pipeline project when working with multiple branches.\nThat&#8217;s why I switched to a Multibranch Pipeline Project later on.</p>\n</div>\n<div class=\"paragraph\">\n<p>At this point, I had several branches, each with a Jenkinsfile.\nI also had Free Tier machines struggling to keep up with the heavy load.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_lets_make_things_a_bit_more_complex\">Let&#8217;s make things a bit more complex</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>As I was testing different tools and stages using different Jenkinsfiles on various branches, I realized that using the same Docker image on all branches was not efficient.\nI started exploring the idea of using a different Docker image per branch, based on the specific tools or tool versions required.\nThis made sense because using a generic Android image would result in additional download time during the build process for non-bundled tool versions.</p>\n</div>\n<div class=\"paragraph\">\n<p>Developers prioritize fast pipelines, and a custom Docker image with the correct tool versions is a way to achieve this.\nHowever, this custom image may not always be present in the Docker cache, resulting in slower builds.</p>\n</div>\n<div class=\"paragraph\">\n<p>To tackle this issue, I decided to automate the Docker image building process and use GitHub Actions to build and push the images to my Docker registry.</p>\n</div>\n<div class=\"paragraph\">\n<p>Of course, achieving a \"fast\" pipeline (around 5 minutes) depends heavily on the agent&#8217;s specificity.\nIf it&#8217;s attached to only one project, then there&#8217;s hope that, even with various versions of the Docker image, the Docker cache would be large enough to ensure that builds fire up immediately.</p>\n</div>\n<div class=\"paragraph\">\n<p>To accomplish this, I had a potentially different Dockerfile per branch, and an image per branch, built using a GitHub Action and pushed to my Docker Hub repository.\nAt that point, I had a working declarative pipeline for each branch, as well as a separate Docker image for each branch.\nUltimately, this allowed me to generate an application binary that was ready to be deployed.</p>\n</div>\n<div class=\"paragraph\">\n<p>Ready? We&#8217;ll see that in the following blog post of this series.</p>\n</div>\n</div>\n</div>","document":{"title":"Building Android apps with Jenkins: an introduction","main":"Building Android apps with Jenkins"},"author":{"fullName":null},"pageAttributes":{"author":"gounthar, kmartens27","tags":"jenkins, android","opengraph":"/post-images/2023/03/29/2023-03-22-android-and-jenkins/love.png"}}},"pageContext":{"id":"8accf1a4-42b0-51b1-bf2b-64d64c263811"}},"staticQueryHashes":[],"slicesMap":{}}